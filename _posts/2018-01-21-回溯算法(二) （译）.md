---
layout:     post                       
title:      回溯算法(二) （译）            
subtitle:   认为是一篇关于回溯的好文章
date:       2018-01-21               
author:     zhangxin                       
header-img: img/post-bg-2015.jpg     
catalog: true                     
tags:                               
    - backtracking
    - algorithm
---

## 不使用递归的回溯

[origin](https://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html)


回溯是个典型的可以是用递归的算法，所有的递归算法都可以使用栈来实现。事实上，这就是的递归算法如何被翻译成机器或者汇编语言的。

```
boolean solve(Node n){
	put node n on stack;
	while the stack is not empty{
		if the node on the top of the stack is leaf{
			if it is a goal node,return true;
			else pop it off the stack
		}else{
			if the node at the top of the stack has untried children
			 push the next untried child into the stack
			else pop the node off the stack
		}
	}
	return false

}
```

 从根结点开始，只有那些当前子结点在栈顶的结点才能压栈，并且一次只能入栈一个子结点。因此，在栈里的结点总是能组成树的一个有效路径。只有知道在结点下没有目标结点时，该结点才会出栈。因此，如果根结点出栈了（栈为空），那么一定没有目标结点了，所以问题无解。

当使用栈的这个算法成功结束后，在栈里的结点就是一个从根结点到目标结点的逆序路径。

相似的，当使用递归算法找到一个目标结点时，路径信息都包括在了一系列的递归调用中。因此随着递归结束，路径可以一次一个结点恢复出来，通过打印当前这一层的结点或者存在一个数组里。

这是一个递归算法，通过简单修改下后使其逆序打印出结果路径上的结点。

```
boolean solve(Node n){
	if n is a leaf node{
		print n
		return true
	}else{
		for each child c of n {
			if solve(c) successd{
				print n
				return true
			}
		}
		return false
	}
}
```

## 保持回溯简单

这些回溯版本的回溯算法都很简单，但是当应用到实际问题时，细节会非常的乱。甚至决定一个结点是否为叶子结点会非常复杂。例如，如果路径表示在国际象棋残局中一系列的走法，那么叶子则表示将死和僵持的解决方案。

因此，为了保证程序简单，像这种测试应该封装在方法中。例如在象棋比赛中，你可以通过下一个`gameOver`的方法来测试一个结点是否为叶子结点（或者你也可以叫它`isLeaf`）。这个方法可以封装所有用来判断是否有下一步的繁琐细节。

注意到回溯要求我们追踪在当前路径里的每一个结点，这些结点的子结点都已经被尝试过（所以我们不用再尝试它们一次）。在上面的代码中，这个看起来很简单，仅仅是通过`for each child c of n`。实际上，判断哪些子结点可能很困难，可能没有很清楚的方法来便利子结点。例如在象棋中，一个结点可能代表在棋盘上一些列的走法，再走了合法一步后，每个子结点则表示下一个一些列走法。你如何能找到这些子结点，并且你如何追踪已经测试过的结点？

最直接的追踪一个结点的子结点是否已经尝试的方式是：一开始初始化一个结点的实例，维护一个所有子结点的列表。当你尝试一个结点时，就把这个结点从列表中移除。当列表为空的时候，就没有未尝试的子结点了，你就可以返回失败了。这是个简单的方法，但是确实需要很多额外的工作。

还有一个梗简单的方式来追踪已经尝试过的子结点，如果你定义了子结点的顺序。如果是有序的，你知道哪个已经尝试过了，你就能决定下一个字结点是哪个。

例如，你可以标记所用子结点从1到n，并且按数字顺序尝试它们。这样，如果你已经尝试了结点k，那么你知道你已经尝试了1到k-1，还没有尝试k+1到n。或者，如果你尝试用四种颜色来标记一个地图，你可以总是先尝试红色，然后黄色，然后绿色，最后蓝色。如果给子结点黄色失败了，就尝试绿色。如果你在走迷宫，你可以按左右，直行来尝试（或者东南西北）。

找到一个简单的方法来定义子结点的顺序并不总是很简单。在象棋游戏的例子中，你可能按数字（或者是一个方块）标记，然后按数字顺序来尝试。

你可能能找到一些方法来给子结点排序。如果排序的方法足够简单，你应该用这个方法。但是如果太笨重，你最好维护一个份还未尝试的子结点的列表。


